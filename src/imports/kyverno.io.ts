// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterPolicy declares validation, mutation, and generation behaviors for matching resources.
 *
 * @schema ClusterPolicy
 */
export class ClusterPolicy extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterPolicy"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kyverno.io/v1',
    kind: 'ClusterPolicy',
  };

  /**
   * Renders a Kubernetes manifest for "ClusterPolicy".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterPolicyProps): any {
    return {
      ...ClusterPolicy.GVK,
      ...toJson_ClusterPolicyProps(props),
    };
  }

  /**
   * Defines a "ClusterPolicy" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterPolicyProps) {
    super(scope, id, {
      ...ClusterPolicy.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterPolicy.GVK,
      ...toJson_ClusterPolicyProps(resolved),
    };
  }
}

/**
 * ClusterPolicy declares validation, mutation, and generation behaviors for matching resources.
 *
 * @schema ClusterPolicy
 */
export interface ClusterPolicyProps {
  /**
   * @schema ClusterPolicy#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec declares policy behaviors.
   *
   * @schema ClusterPolicy#spec
   */
  readonly spec: ClusterPolicySpec;

}

/**
 * Converts an object of type 'ClusterPolicyProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicyProps(obj: ClusterPolicyProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterPolicySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Spec declares policy behaviors.
 *
 * @schema ClusterPolicySpec
 */
export interface ClusterPolicySpec {
  /**
   * ApplyRules controls how rules in a policy are applied. Rule are processed in the order of declaration. When set to `One` processing stops after a rule has been applied i.e. the rule matches and results in a pass, fail, or error. When set to `All` all rules in the policy are processed. The default is `All`.
   *
   * @schema ClusterPolicySpec#applyRules
   */
  readonly applyRules?: ClusterPolicySpecApplyRules;

  /**
   * Background controls if rules are applied to existing resources during a background scan. Optional. Default value is "true". The value must be set to "false" if the policy rule uses variables that are only available in the admission review request (e.g. user name).
   *
   * @schema ClusterPolicySpec#background
   */
  readonly background?: boolean;

  /**
   * FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled. Rules within the same policy share the same failure behavior. Allowed values are Ignore or Fail. Defaults to Fail.
   *
   * @default Fail.
   * @schema ClusterPolicySpec#failurePolicy
   */
  readonly failurePolicy?: ClusterPolicySpecFailurePolicy;

  /**
   * GenerateExistingOnPolicyUpdate controls whether to trigger generate rule in existing resources If is set to "true" generate rule will be triggered and applied to existing matched resources. Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicySpec#generateExistingOnPolicyUpdate
   */
  readonly generateExistingOnPolicyUpdate?: boolean;

  /**
   * MutateExistingOnPolicyUpdate controls if a mutateExisting policy is applied on policy events. Default value is "false".
   *
   * @schema ClusterPolicySpec#mutateExistingOnPolicyUpdate
   */
  readonly mutateExistingOnPolicyUpdate?: boolean;

  /**
   * Rules is a list of Rule instances. A Policy contains multiple rules and each rule can validate, mutate, or generate resources.
   *
   * @schema ClusterPolicySpec#rules
   */
  readonly rules?: ClusterPolicySpecRules[];

  /**
   * SchemaValidation skips policy validation checks. Optional. The default value is set to "true", it must be set to "false" to disable the validation checks.
   *
   * @schema ClusterPolicySpec#schemaValidation
   */
  readonly schemaValidation?: boolean;

  /**
   * ValidationFailureAction defines if a validation policy rule violation should block the admission review request (enforce), or allow (audit) the admission review request and report an error in a policy report. Optional. Allowed values are audit or enforce. The default value is "audit".
   *
   * @schema ClusterPolicySpec#validationFailureAction
   */
  readonly validationFailureAction?: ClusterPolicySpecValidationFailureAction;

  /**
   * ValidationFailureActionOverrides is a Cluster Policy attribute that specifies ValidationFailureAction namespace-wise. It overrides ValidationFailureAction for the specified namespaces.
   *
   * @schema ClusterPolicySpec#validationFailureActionOverrides
   */
  readonly validationFailureActionOverrides?: ClusterPolicySpecValidationFailureActionOverrides[];

  /**
   * WebhookTimeoutSeconds specifies the maximum time in seconds allowed to apply this policy. After the configured time expires, the admission request may fail, or may simply ignore the policy results, based on the failure policy. The default timeout is 10s, the value must be between 1 and 30 seconds.
   *
   * @schema ClusterPolicySpec#webhookTimeoutSeconds
   */
  readonly webhookTimeoutSeconds?: number;

}

/**
 * Converts an object of type 'ClusterPolicySpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpec(obj: ClusterPolicySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applyRules': obj.applyRules,
    'background': obj.background,
    'failurePolicy': obj.failurePolicy,
    'generateExistingOnPolicyUpdate': obj.generateExistingOnPolicyUpdate,
    'mutateExistingOnPolicyUpdate': obj.mutateExistingOnPolicyUpdate,
    'rules': obj.rules?.map(y => toJson_ClusterPolicySpecRules(y)),
    'schemaValidation': obj.schemaValidation,
    'validationFailureAction': obj.validationFailureAction,
    'validationFailureActionOverrides': obj.validationFailureActionOverrides?.map(y => toJson_ClusterPolicySpecValidationFailureActionOverrides(y)),
    'webhookTimeoutSeconds': obj.webhookTimeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ApplyRules controls how rules in a policy are applied. Rule are processed in the order of declaration. When set to `One` processing stops after a rule has been applied i.e. the rule matches and results in a pass, fail, or error. When set to `All` all rules in the policy are processed. The default is `All`.
 *
 * @schema ClusterPolicySpecApplyRules
 */
export enum ClusterPolicySpecApplyRules {
  /** All */
  ALL = 'All',
  /** One */
  ONE = 'One',
}

/**
 * FailurePolicy defines how unexpected policy errors and webhook response timeout errors are handled. Rules within the same policy share the same failure behavior. Allowed values are Ignore or Fail. Defaults to Fail.
 *
 * @default Fail.
 * @schema ClusterPolicySpecFailurePolicy
 */
export enum ClusterPolicySpecFailurePolicy {
  /** Ignore */
  IGNORE = 'Ignore',
  /** Fail */
  FAIL = 'Fail',
}

/**
 * Rule defines a validation, mutation, or generation control for matching resources. Each rules contains a match declaration to select resources, and an optional exclude declaration to specify which resources to exclude.
 *
 * @schema ClusterPolicySpecRules
 */
export interface ClusterPolicySpecRules {
  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRules#context
   */
  readonly context?: ClusterPolicySpecRulesContext[];

  /**
   * ExcludeResources defines when this policy rule should not be applied. The exclude criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the name or role.
   *
   * @schema ClusterPolicySpecRules#exclude
   */
  readonly exclude?: ClusterPolicySpecRulesExclude;

  /**
   * Generation is used to create new resources.
   *
   * @schema ClusterPolicySpecRules#generate
   */
  readonly generate?: ClusterPolicySpecRulesGenerate;

  /**
   * ImageExtractors defines a mapping from kinds to ImageExtractorConfigs. This config is only valid for verifyImages rules.
   *
   * @schema ClusterPolicySpecRules#imageExtractors
   */
  readonly imageExtractors?: { [key: string]: ClusterPolicySpecRulesImageExtractors[] };

  /**
   * MatchResources defines when this policy rule should be applied. The match criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the user name or role. At least one kind is required.
   *
   * @schema ClusterPolicySpecRules#match
   */
  readonly match?: ClusterPolicySpecRulesMatch;

  /**
   * Mutation is used to modify matching resources.
   *
   * @schema ClusterPolicySpecRules#mutate
   */
  readonly mutate?: ClusterPolicySpecRulesMutate;

  /**
   * Name is a label to identify the rule, It must be unique within the policy.
   *
   * @schema ClusterPolicySpecRules#name
   */
  readonly name?: string;

  /**
   * Preconditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested `any` or `all` statements. A direct list of conditions (without `any` or `all` statements is supported for backwards compatibility but will be deprecated in the next major release. See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRules#preconditions
   */
  readonly preconditions?: any;

  /**
   * Validation is used to validate matching resources.
   *
   * @schema ClusterPolicySpecRules#validate
   */
  readonly validate?: ClusterPolicySpecRulesValidate;

  /**
   * VerifyImages is used to verify image signatures and mutate them to add a digest
   *
   * @schema ClusterPolicySpecRules#verifyImages
   */
  readonly verifyImages?: ClusterPolicySpecRulesVerifyImages[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRules' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRules(obj: ClusterPolicySpecRules | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesContext(y)),
    'exclude': toJson_ClusterPolicySpecRulesExclude(obj.exclude),
    'generate': toJson_ClusterPolicySpecRulesGenerate(obj.generate),
    'imageExtractors': ((obj.imageExtractors) === undefined) ? undefined : (Object.entries(obj.imageExtractors).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1]?.map(y => toJson_ClusterPolicySpecRulesImageExtractors(y)) }), {})),
    'match': toJson_ClusterPolicySpecRulesMatch(obj.match),
    'mutate': toJson_ClusterPolicySpecRulesMutate(obj.mutate),
    'name': obj.name,
    'preconditions': obj.preconditions,
    'validate': toJson_ClusterPolicySpecRulesValidate(obj.validate),
    'verifyImages': obj.verifyImages?.map(y => toJson_ClusterPolicySpecRulesVerifyImages(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValidationFailureAction defines if a validation policy rule violation should block the admission review request (enforce), or allow (audit) the admission review request and report an error in a policy report. Optional. Allowed values are audit or enforce. The default value is "audit".
 *
 * @schema ClusterPolicySpecValidationFailureAction
 */
export enum ClusterPolicySpecValidationFailureAction {
  /** audit */
  AUDIT = 'audit',
  /** enforce */
  ENFORCE = 'enforce',
}

/**
 * @schema ClusterPolicySpecValidationFailureActionOverrides
 */
export interface ClusterPolicySpecValidationFailureActionOverrides {
  /**
   * ValidationFailureAction defines the policy validation failure action
   *
   * @schema ClusterPolicySpecValidationFailureActionOverrides#action
   */
  readonly action?: ClusterPolicySpecValidationFailureActionOverridesAction;

  /**
   * @schema ClusterPolicySpecValidationFailureActionOverrides#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecValidationFailureActionOverrides' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecValidationFailureActionOverrides(obj: ClusterPolicySpecValidationFailureActionOverrides | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'action': obj.action,
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesContext
 */
export interface ClusterPolicySpecRulesContext {
  /**
   * APICall defines an HTTP request to the Kubernetes API server. The JSON data retrieved is stored in the context.
   *
   * @schema ClusterPolicySpecRulesContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesContextConfigMap;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
   *
   * @schema ClusterPolicySpecRulesContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesContext#name
   */
  readonly name?: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContext(obj: ClusterPolicySpecRulesContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesContextConfigMap(obj.configMap),
    'imageRegistry': toJson_ClusterPolicySpecRulesContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ExcludeResources defines when this policy rule should not be applied. The exclude criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the name or role.
 *
 * @schema ClusterPolicySpecRulesExclude
 */
export interface ClusterPolicySpecRulesExclude {
  /**
   * All allows specifying resources which will be ANDed
   *
   * @schema ClusterPolicySpecRulesExclude#all
   */
  readonly all?: ClusterPolicySpecRulesExcludeAll[];

  /**
   * Any allows specifying resources which will be ORed
   *
   * @schema ClusterPolicySpecRulesExclude#any
   */
  readonly any?: ClusterPolicySpecRulesExcludeAny[];

  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesExclude#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified. Requires at least one tag to be specified when under MatchResources. Specifying ResourceDescription directly under match is being deprecated. Please specify under "any" or "all" instead.
   *
   * @schema ClusterPolicySpecRulesExclude#resources
   */
  readonly resources?: ClusterPolicySpecRulesExcludeResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesExclude#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesExclude#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesExcludeSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExclude' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExclude(obj: ClusterPolicySpecRulesExclude | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesExcludeAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesExcludeAny(y)),
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesExcludeResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesExcludeSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Generation is used to create new resources.
 *
 * @schema ClusterPolicySpecRulesGenerate
 */
export interface ClusterPolicySpecRulesGenerate {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicySpecRulesGenerate#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Clone specifies the source resource used to populate each generated resource. At most one of Data or Clone can be specified. If neither are provided, the generated resource will be created with default data only.
   *
   * @schema ClusterPolicySpecRulesGenerate#clone
   */
  readonly clone?: ClusterPolicySpecRulesGenerateClone;

  /**
   * Data provides the resource declaration used to populate each generated resource. At most one of Data or Clone must be specified. If neither are provided, the generated resource will be created with default data only.
   *
   * @schema ClusterPolicySpecRulesGenerate#data
   */
  readonly data?: any;

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicySpecRulesGenerate#kind
   */
  readonly kind?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicySpecRulesGenerate#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerate#namespace
   */
  readonly namespace?: string;

  /**
   * Synchronize controls if generated resources should be kept in-sync with their source resource. If Synchronize is set to "true" changes to generated resources will be overwritten with resource data from Data or the resource specified in the Clone declaration. Optional. Defaults to "false" if not specified.
   *
   * @default false" if not specified.
   * @schema ClusterPolicySpecRulesGenerate#synchronize
   */
  readonly synchronize?: boolean;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerate(obj: ClusterPolicySpecRulesGenerate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'clone': toJson_ClusterPolicySpecRulesGenerateClone(obj.clone),
    'data': obj.data,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
    'synchronize': obj.synchronize,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesImageExtractors
 */
export interface ClusterPolicySpecRulesImageExtractors {
  /**
   * Key is an optional name of the field within 'path' that will be used to uniquely identify an image. Note - this field MUST be unique.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#key
   */
  readonly key?: string;

  /**
   * Name is the entry the image will be available under 'images.<name>' in the context. If this field is not defined, image entries will appear under 'images.custom'.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#name
   */
  readonly name?: string;

  /**
   * Path is the path to the object containing the image field in a custom resource. It should be slash-separated. Each slash-separated key must be a valid YAML key or a wildcard '*'. Wildcard keys are expanded in case of arrays or objects.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#path
   */
  readonly path: string;

  /**
   * Value is an optional name of the field within 'path' that points to the image URI. This is useful when a custom 'key' is also defined.
   *
   * @schema ClusterPolicySpecRulesImageExtractors#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesImageExtractors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesImageExtractors(obj: ClusterPolicySpecRulesImageExtractors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'path': obj.path,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * MatchResources defines when this policy rule should be applied. The match criteria can include resource information (e.g. kind, name, namespace, labels) and admission review request information like the user name or role. At least one kind is required.
 *
 * @schema ClusterPolicySpecRulesMatch
 */
export interface ClusterPolicySpecRulesMatch {
  /**
   * All allows specifying resources which will be ANDed
   *
   * @schema ClusterPolicySpecRulesMatch#all
   */
  readonly all?: ClusterPolicySpecRulesMatchAll[];

  /**
   * Any allows specifying resources which will be ORed
   *
   * @schema ClusterPolicySpecRulesMatch#any
   */
  readonly any?: ClusterPolicySpecRulesMatchAny[];

  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatch#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified. Requires at least one tag to be specified when under MatchResources. Specifying ResourceDescription directly under match is being deprecated. Please specify under "any" or "all" instead.
   *
   * @schema ClusterPolicySpecRulesMatch#resources
   */
  readonly resources?: ClusterPolicySpecRulesMatchResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatch#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesMatch#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesMatchSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatch' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatch(obj: ClusterPolicySpecRulesMatch | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesMatchAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesMatchAny(y)),
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesMatchResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesMatchSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Mutation is used to modify matching resources.
 *
 * @schema ClusterPolicySpecRulesMutate
 */
export interface ClusterPolicySpecRulesMutate {
  /**
   * ForEach applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicySpecRulesMutate#foreach
   */
  readonly foreach?: ClusterPolicySpecRulesMutateForeach[];

  /**
   * PatchStrategicMerge is a strategic merge patch used to modify resources. See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/ and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
   *
   * @schema ClusterPolicySpecRulesMutate#patchStrategicMerge
   */
  readonly patchStrategicMerge?: any;

  /**
   * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources. See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
   *
   * @schema ClusterPolicySpecRulesMutate#patchesJson6902
   */
  readonly patchesJson6902?: string;

  /**
   * Targets defines the target resources to be mutated.
   *
   * @schema ClusterPolicySpecRulesMutate#targets
   */
  readonly targets?: ClusterPolicySpecRulesMutateTargets[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutate(obj: ClusterPolicySpecRulesMutate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicySpecRulesMutateForeach(y)),
    'patchStrategicMerge': obj.patchStrategicMerge,
    'patchesJson6902': obj.patchesJson6902,
    'targets': obj.targets?.map(y => toJson_ClusterPolicySpecRulesMutateTargets(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Validation is used to validate matching resources.
 *
 * @schema ClusterPolicySpecRulesValidate
 */
export interface ClusterPolicySpecRulesValidate {
  /**
   * AnyPattern specifies list of validation patterns. At least one of the patterns must be satisfied for the validation rule to succeed.
   *
   * @schema ClusterPolicySpecRulesValidate#anyPattern
   */
  readonly anyPattern?: any;

  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicySpecRulesValidate#deny
   */
  readonly deny?: ClusterPolicySpecRulesValidateDeny;

  /**
   * ForEach applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
   *
   * @schema ClusterPolicySpecRulesValidate#foreach
   */
  readonly foreach?: ClusterPolicySpecRulesValidateForeach[];

  /**
   * Message specifies a custom message to be displayed on failure.
   *
   * @schema ClusterPolicySpecRulesValidate#message
   */
  readonly message?: string;

  /**
   * Pattern specifies an overlay-style pattern used to check resources.
   *
   * @schema ClusterPolicySpecRulesValidate#pattern
   */
  readonly pattern?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidate(obj: ClusterPolicySpecRulesValidate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anyPattern': obj.anyPattern,
    'deny': toJson_ClusterPolicySpecRulesValidateDeny(obj.deny),
    'foreach': obj.foreach?.map(y => toJson_ClusterPolicySpecRulesValidateForeach(y)),
    'message': obj.message,
    'pattern': obj.pattern,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageVerification validates that images that match the specified pattern are signed with the supplied public key. Once the image is verified it is mutated to include the SHA digest retrieved during the registration.
 *
 * @schema ClusterPolicySpecRulesVerifyImages
 */
export interface ClusterPolicySpecRulesVerifyImages {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing. Deprecated.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * Annotations are used for image verification. Every specified key-value pair must exist and match in the verified payload. The payload may contain other key-value pairs. Deprecated. Use annotations per Attestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestations are optional checks for signed in-toto Statements used to verify the image. See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the OCI registry and decodes them into a list of Statement declarations.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#attestations
   */
  readonly attestations?: ClusterPolicySpecRulesVerifyImagesAttestations[];

  /**
   * Attestors specified the required attestors (i.e. authorities)
   *
   * @schema ClusterPolicySpecRulesVerifyImages#attestors
   */
  readonly attestors?: ClusterPolicySpecRulesVerifyImagesAttestors[];

  /**
   * Image is the image name consisting of the registry address, repository, image, and tag. Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images. Deprecated. Use ImageReferences instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#image
   */
  readonly image?: string;

  /**
   * ImageReferences is a list of matching image reference patterns. At least one pattern in the list must match the image for the rule to apply. Each image reference consists of a registry address (defaults to docker.io), repository, image, and tag (defaults to latest). Wildcards ('*' and '?') are allowed. See: https://kubernetes.io/docs/concepts/containers/images.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#imageReferences
   */
  readonly imageReferences?: string[];

  /**
   * Issuer is the certificate issuer used for keyless signing. Deprecated. Use KeylessAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#issuer
   */
  readonly issuer?: string;

  /**
   * Key is the PEM encoded public key that the image or attestation is signed with. Deprecated. Use StaticKeyAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#key
   */
  readonly key?: string;

  /**
   * MutateDigest enables replacement of image tags with digests. Defaults to true.
   *
   * @default true.
   * @schema ClusterPolicySpecRulesVerifyImages#mutateDigest
   */
  readonly mutateDigest?: boolean;

  /**
   * Repository is an optional alternate OCI repository to use for image signatures and attestations that match this rule. If specified Repository will override the default OCI image repository configured for the installation. The repository can also be overridden per Attestor or Attestation.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#repository
   */
  readonly repository?: string;

  /**
   * Required validates that images are verified i.e. have matched passed a signature or attestation check.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#required
   */
  readonly required?: boolean;

  /**
   * Roots is the PEM encoded Root certificate chain used for keyless signing Deprecated. Use KeylessAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#roots
   */
  readonly roots?: string;

  /**
   * Subject is the identity used for keyless signing, for example an email address Deprecated. Use KeylessAttestor instead.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#subject
   */
  readonly subject?: string;

  /**
   * VerifyDigest validates that images have a digest.
   *
   * @schema ClusterPolicySpecRulesVerifyImages#verifyDigest
   */
  readonly verifyDigest?: boolean;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImages' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImages(obj: ClusterPolicySpecRulesVerifyImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestations': obj.attestations?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestations(y)),
    'attestors': obj.attestors?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestors(y)),
    'image': obj.image,
    'imageReferences': obj.imageReferences?.map(y => y),
    'issuer': obj.issuer,
    'key': obj.key,
    'mutateDigest': obj.mutateDigest,
    'repository': obj.repository,
    'required': obj.required,
    'roots': obj.roots,
    'subject': obj.subject,
    'verifyDigest': obj.verifyDigest,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ValidationFailureAction defines the policy validation failure action
 *
 * @schema ClusterPolicySpecValidationFailureActionOverridesAction
 */
export enum ClusterPolicySpecValidationFailureActionOverridesAction {
  /** audit */
  AUDIT = 'audit',
  /** enforce */
  ENFORCE = 'enforce',
}

/**
 * APICall defines an HTTP request to the Kubernetes API server. The JSON data retrieved is stored in the context.
 *
 * @schema ClusterPolicySpecRulesContextApiCall
 */
export interface ClusterPolicySpecRulesContextApiCall {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the API server. For example a JMESPath of "items | length(@)" applied to the API server response to the URLPath "/apis/apps/v1/deployments" will return the total count of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * URLPath is the URL path to be used in the HTTP GET request to the Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments"). The format required is the same format used by the `kubectl get --raw` command.
   *
   * @schema ClusterPolicySpecRulesContextApiCall#urlPath
   */
  readonly urlPath: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextApiCall(obj: ClusterPolicySpecRulesContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesContextConfigMap
 */
export interface ClusterPolicySpecRulesContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextConfigMap(obj: ClusterPolicySpecRulesContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
 *
 * @schema ClusterPolicySpecRulesContextImageRegistry
 */
export interface ClusterPolicySpecRulesContextImageRegistry {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
   *
   * @schema ClusterPolicySpecRulesContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextImageRegistry(obj: ClusterPolicySpecRulesContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesContextVariable
 */
export interface ClusterPolicySpecRulesContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
   * @schema ClusterPolicySpecRulesContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
   *
   * @schema ClusterPolicySpecRulesContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesContextVariable(obj: ClusterPolicySpecRulesContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesExcludeAll
 */
export interface ClusterPolicySpecRulesExcludeAll {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#resources
   */
  readonly resources?: ClusterPolicySpecRulesExcludeAllResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesExcludeAll#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesExcludeAllSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAll(obj: ClusterPolicySpecRulesExcludeAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesExcludeAllResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesExcludeAllSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesExcludeAny
 */
export interface ClusterPolicySpecRulesExcludeAny {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#resources
   */
  readonly resources?: ClusterPolicySpecRulesExcludeAnyResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesExcludeAny#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesExcludeAnySubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAny(obj: ClusterPolicySpecRulesExcludeAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesExcludeAnyResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesExcludeAnySubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified. Requires at least one tag to be specified when under MatchResources. Specifying ResourceDescription directly under match is being deprecated. Please specify under "any" or "all" instead.
 *
 * @schema ClusterPolicySpecRulesExcludeResources
 */
export interface ClusterPolicySpecRulesExcludeResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesExcludeResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesExcludeResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesExcludeResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesExcludeResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResources(obj: ClusterPolicySpecRulesExcludeResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesExcludeResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesExcludeSubjects
 */
export interface ClusterPolicySpecRulesExcludeSubjects {
  /**
   * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   * @schema ClusterPolicySpecRulesExcludeSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesExcludeSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeSubjects(obj: ClusterPolicySpecRulesExcludeSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Clone specifies the source resource used to populate each generated resource. At most one of Data or Clone can be specified. If neither are provided, the generated resource will be created with default data only.
 *
 * @schema ClusterPolicySpecRulesGenerateClone
 */
export interface ClusterPolicySpecRulesGenerateClone {
  /**
   * Name specifies name of the resource.
   *
   * @schema ClusterPolicySpecRulesGenerateClone#name
   */
  readonly name?: string;

  /**
   * Namespace specifies source resource namespace.
   *
   * @schema ClusterPolicySpecRulesGenerateClone#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesGenerateClone' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesGenerateClone(obj: ClusterPolicySpecRulesGenerateClone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesMatchAll
 */
export interface ClusterPolicySpecRulesMatchAll {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAll#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesMatchAll#resources
   */
  readonly resources?: ClusterPolicySpecRulesMatchAllResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAll#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesMatchAll#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesMatchAllSubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAll(obj: ClusterPolicySpecRulesMatchAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesMatchAllResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesMatchAllSubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceFilter allow users to "AND" or "OR" between resources
 *
 * @schema ClusterPolicySpecRulesMatchAny
 */
export interface ClusterPolicySpecRulesMatchAny {
  /**
   * ClusterRoles is the list of cluster-wide role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAny#clusterRoles
   */
  readonly clusterRoles?: string[];

  /**
   * ResourceDescription contains information about the resource being created or modified.
   *
   * @schema ClusterPolicySpecRulesMatchAny#resources
   */
  readonly resources?: ClusterPolicySpecRulesMatchAnyResources;

  /**
   * Roles is the list of namespaced role names for the user.
   *
   * @schema ClusterPolicySpecRulesMatchAny#roles
   */
  readonly roles?: string[];

  /**
   * Subjects is the list of subject names like users, user groups, and service accounts.
   *
   * @schema ClusterPolicySpecRulesMatchAny#subjects
   */
  readonly subjects?: ClusterPolicySpecRulesMatchAnySubjects[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAny(obj: ClusterPolicySpecRulesMatchAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterRoles': obj.clusterRoles?.map(y => y),
    'resources': toJson_ClusterPolicySpecRulesMatchAnyResources(obj.resources),
    'roles': obj.roles?.map(y => y),
    'subjects': obj.subjects?.map(y => toJson_ClusterPolicySpecRulesMatchAnySubjects(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified. Requires at least one tag to be specified when under MatchResources. Specifying ResourceDescription directly under match is being deprecated. Please specify under "any" or "all" instead.
 *
 * @schema ClusterPolicySpecRulesMatchResources
 */
export interface ClusterPolicySpecRulesMatchResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesMatchResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesMatchResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesMatchResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesMatchResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResources(obj: ClusterPolicySpecRulesMatchResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesMatchResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesMatchSubjects
 */
export interface ClusterPolicySpecRulesMatchSubjects {
  /**
   * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   * @schema ClusterPolicySpecRulesMatchSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesMatchSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchSubjects(obj: ClusterPolicySpecRulesMatchSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ForEach applies mutation rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
 *
 * @schema ClusterPolicySpecRulesMutateForeach
 */
export interface ClusterPolicySpecRulesMutateForeach {
  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#context
   */
  readonly context?: ClusterPolicySpecRulesMutateForeachContext[];

  /**
   * List specifies a JMESPath expression that results in one or more elements to which the validation logic is applied.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#list
   */
  readonly list?: string;

  /**
   * PatchStrategicMerge is a strategic merge patch used to modify resources. See https://kubernetes.io/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/ and https://kubectl.docs.kubernetes.io/references/kustomize/patchesstrategicmerge/.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#patchStrategicMerge
   */
  readonly patchStrategicMerge?: any;

  /**
   * PatchesJSON6902 is a list of RFC 6902 JSON Patch declarations used to modify resources. See https://tools.ietf.org/html/rfc6902 and https://kubectl.docs.kubernetes.io/references/kustomize/patchesjson6902/.
   *
   * @schema ClusterPolicySpecRulesMutateForeach#patchesJson6902
   */
  readonly patchesJson6902?: string;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested `any` or `all` statements. See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRulesMutateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicySpecRulesMutateForeachPreconditions;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeach(obj: ClusterPolicySpecRulesMutateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesMutateForeachContext(y)),
    'list': obj.list,
    'patchStrategicMerge': obj.patchStrategicMerge,
    'patchesJson6902': obj.patchesJson6902,
    'preconditions': toJson_ClusterPolicySpecRulesMutateForeachPreconditions(obj.preconditions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesMutateTargets
 */
export interface ClusterPolicySpecRulesMutateTargets {
  /**
   * APIVersion specifies resource apiVersion.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Kind specifies resource kind.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#kind
   */
  readonly kind?: string;

  /**
   * Name specifies the resource name.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#name
   */
  readonly name?: string;

  /**
   * Namespace specifies resource namespace.
   *
   * @schema ClusterPolicySpecRulesMutateTargets#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateTargets' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateTargets(obj: ClusterPolicySpecRulesMutateTargets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicySpecRulesValidateDeny
 */
export interface ClusterPolicySpecRulesValidateDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement. A direct list of conditions (without `any` or `all` statements) is also supported for backwards compatibility but will be deprecated in the next major release. See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicySpecRulesValidateDeny#conditions
   */
  readonly conditions?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateDeny(obj: ClusterPolicySpecRulesValidateDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ForEach applies validate rules to a list of sub-elements by creating a context for each entry in the list and looping over it to apply the specified logic.
 *
 * @schema ClusterPolicySpecRulesValidateForeach
 */
export interface ClusterPolicySpecRulesValidateForeach {
  /**
   * AnyPattern specifies list of validation patterns. At least one of the patterns must be satisfied for the validation rule to succeed.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#anyPattern
   */
  readonly anyPattern?: any;

  /**
   * Context defines variables and data sources that can be used during rule execution.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#context
   */
  readonly context?: ClusterPolicySpecRulesValidateForeachContext[];

  /**
   * Deny defines conditions used to pass or fail a validation rule.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#deny
   */
  readonly deny?: ClusterPolicySpecRulesValidateForeachDeny;

  /**
   * ElementScope specifies whether to use the current list element as the scope for validation. Defaults to "true" if not specified. When set to "false", "request.object" is used as the validation scope within the foreach block to allow referencing other elements in the subtree.
   *
   * @default true" if not specified. When set to "false", "request.object" is used as the validation scope within the foreach block to allow referencing other elements in the subtree.
   * @schema ClusterPolicySpecRulesValidateForeach#elementScope
   */
  readonly elementScope?: boolean;

  /**
   * List specifies a JMESPath expression that results in one or more elements to which the validation logic is applied.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#list
   */
  readonly list?: string;

  /**
   * Pattern specifies an overlay-style pattern used to check resources.
   *
   * @schema ClusterPolicySpecRulesValidateForeach#pattern
   */
  readonly pattern?: any;

  /**
   * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested `any` or `all` statements. See: https://kyverno.io/docs/writing-policies/preconditions/
   *
   * @schema ClusterPolicySpecRulesValidateForeach#preconditions
   */
  readonly preconditions?: ClusterPolicySpecRulesValidateForeachPreconditions;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeach' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeach(obj: ClusterPolicySpecRulesValidateForeach | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anyPattern': obj.anyPattern,
    'context': obj.context?.map(y => toJson_ClusterPolicySpecRulesValidateForeachContext(y)),
    'deny': toJson_ClusterPolicySpecRulesValidateForeachDeny(obj.deny),
    'elementScope': obj.elementScope,
    'list': obj.list,
    'pattern': obj.pattern,
    'preconditions': toJson_ClusterPolicySpecRulesValidateForeachPreconditions(obj.preconditions),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Attestation are checks for signed in-toto Statements that are used to verify the image. See https://github.com/in-toto/attestation. Kyverno fetches signed attestations from the OCI registry and decodes them into a list of Statements.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestations
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestations {
  /**
   * Conditions are used to verify attributes within a Predicate. If no Conditions are specified the attestation check is satisfied as long there are predicates that match the predicate type.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestations#conditions
   */
  readonly conditions?: ClusterPolicySpecRulesVerifyImagesAttestationsConditions[];

  /**
   * PredicateType defines the type of Predicate contained within the Statement.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestations#predicateType
   */
  readonly predicateType?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestations' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestations(obj: ClusterPolicySpecRulesVerifyImagesAttestations | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditions(y)),
    'predicateType': obj.predicateType,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesVerifyImagesAttestors
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestors {
  /**
   * Count specifies the required number of entries that must match. If the count is null, all entries must match (a logical AND). If the count is 1, at least one entry must match (a logical OR). If the count contains a value N, then N must be less than or equal to the size of entries, and at least N entries must match.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestors#count
   */
  readonly count?: number;

  /**
   * Entries contains the available attestors. An attestor can be a static key, attributes for keyless verification, or a nested attestor declaration.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestors#entries
   */
  readonly entries?: ClusterPolicySpecRulesVerifyImagesAttestorsEntries[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestors' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestors(obj: ClusterPolicySpecRulesVerifyImagesAttestors | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'count': obj.count,
    'entries': obj.entries?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntries(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResources
 */
export interface ClusterPolicySpecRulesExcludeAllResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesExcludeAllResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResources(obj: ClusterPolicySpecRulesExcludeAllResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesExcludeAllResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesExcludeAllSubjects
 */
export interface ClusterPolicySpecRulesExcludeAllSubjects {
  /**
   * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAllSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllSubjects(obj: ClusterPolicySpecRulesExcludeAllSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResources
 */
export interface ClusterPolicySpecRulesExcludeAnyResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesExcludeAnyResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResources(obj: ClusterPolicySpecRulesExcludeAnyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesExcludeAnySubjects
 */
export interface ClusterPolicySpecRulesExcludeAnySubjects {
  /**
   * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesExcludeAnySubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnySubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnySubjects(obj: ClusterPolicySpecRulesExcludeAnySubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesExcludeResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelector(obj: ClusterPolicySpecRulesExcludeResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesSelector
 */
export interface ClusterPolicySpecRulesExcludeResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesSelector(obj: ClusterPolicySpecRulesExcludeResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesMatchAllResources
 */
export interface ClusterPolicySpecRulesMatchAllResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAllResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesMatchAllResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResources(obj: ClusterPolicySpecRulesMatchAllResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesMatchAllResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesMatchAllSubjects
 */
export interface ClusterPolicySpecRulesMatchAllSubjects {
  /**
   * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   * @schema ClusterPolicySpecRulesMatchAllSubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAllSubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesMatchAllSubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAllSubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllSubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllSubjects(obj: ClusterPolicySpecRulesMatchAllSubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ResourceDescription contains information about the resource being created or modified.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResources
 */
export interface ClusterPolicySpecRulesMatchAnyResources {
  /**
   * Annotations is a  map of annotations (key-value pairs of type string). Annotation keys and values support the wildcard characters "*" (matches zero or many characters) and "?" (matches at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Kinds is a list of resource kinds.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#kinds
   */
  readonly kinds?: string[];

  /**
   * Name is the name of the resource. The name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character). NOTE: "Name" is being deprecated in favor of "Names".
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#name
   */
  readonly name?: string;

  /**
   * Names are the names of the resources. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#names
   */
  readonly names?: string[];

  /**
   * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#namespaceSelector
   */
  readonly namespaceSelector?: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector;

  /**
   * Namespaces is a list of namespaces names. Each name supports wildcard characters "*" (matches zero or many characters) and "?" (at least one character).
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#namespaces
   */
  readonly namespaces?: string[];

  /**
   * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResources#selector
   */
  readonly selector?: ClusterPolicySpecRulesMatchAnyResourcesSelector;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResources' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResources(obj: ClusterPolicySpecRulesMatchAnyResources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'kinds': obj.kinds?.map(y => y),
    'name': obj.name,
    'names': obj.names?.map(y => y),
    'namespaceSelector': toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
    'selector': toJson_ClusterPolicySpecRulesMatchAnyResourcesSelector(obj.selector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Subject contains a reference to the object or user identities a role binding applies to.  This can either hold a direct API object reference, or a value for non-objects such as user and group names.
 *
 * @schema ClusterPolicySpecRulesMatchAnySubjects
 */
export interface ClusterPolicySpecRulesMatchAnySubjects {
  /**
   * APIGroup holds the API group of the referenced subject. Defaults to "" for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   *
   * @default for ServiceAccount subjects. Defaults to "rbac.authorization.k8s.io" for User and Group subjects.
   * @schema ClusterPolicySpecRulesMatchAnySubjects#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind of object being referenced. Values defined by this API group are "User", "Group", and "ServiceAccount". If the Authorizer does not recognized the kind value, the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAnySubjects#kind
   */
  readonly kind: string;

  /**
   * Name of the object being referenced.
   *
   * @schema ClusterPolicySpecRulesMatchAnySubjects#name
   */
  readonly name: string;

  /**
   * Namespace of the referenced object.  If the object kind is non-namespace, such as "User" or "Group", and this value is not empty the Authorizer should report an error.
   *
   * @schema ClusterPolicySpecRulesMatchAnySubjects#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnySubjects' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnySubjects(obj: ClusterPolicySpecRulesMatchAnySubjects | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiGroup': obj.apiGroup,
    'kind': obj.kind,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesMatchResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelector(obj: ClusterPolicySpecRulesMatchResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesSelector
 */
export interface ClusterPolicySpecRulesMatchResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesSelector(obj: ClusterPolicySpecRulesMatchResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContext
 */
export interface ClusterPolicySpecRulesMutateForeachContext {
  /**
   * APICall defines an HTTP request to the Kubernetes API server. The JSON data retrieved is stored in the context.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesMutateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesMutateForeachContextConfigMap;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesMutateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#name
   */
  readonly name?: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesMutateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContext(obj: ClusterPolicySpecRulesMutateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesMutateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesMutateForeachContextConfigMap(obj.configMap),
    'imageRegistry': toJson_ClusterPolicySpecRulesMutateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesMutateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested `any` or `all` statements. See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditions
 */
export interface ClusterPolicySpecRulesMutateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditions#all
   */
  readonly all?: ClusterPolicySpecRulesMutateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditions#any
   */
  readonly any?: ClusterPolicySpecRulesMutateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachPreconditions(obj: ClusterPolicySpecRulesMutateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ContextEntry adds variables and data sources to a rule Context. Either a ConfigMap reference or a APILookup must be provided.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContext
 */
export interface ClusterPolicySpecRulesValidateForeachContext {
  /**
   * APICall defines an HTTP request to the Kubernetes API server. The JSON data retrieved is stored in the context.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#apiCall
   */
  readonly apiCall?: ClusterPolicySpecRulesValidateForeachContextApiCall;

  /**
   * ConfigMap is the ConfigMap reference.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#configMap
   */
  readonly configMap?: ClusterPolicySpecRulesValidateForeachContextConfigMap;

  /**
   * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#imageRegistry
   */
  readonly imageRegistry?: ClusterPolicySpecRulesValidateForeachContextImageRegistry;

  /**
   * Name is the variable name.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#name
   */
  readonly name?: string;

  /**
   * Variable defines an arbitrary JMESPath context variable that can be defined inline.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContext#variable
   */
  readonly variable?: ClusterPolicySpecRulesValidateForeachContextVariable;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContext' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContext(obj: ClusterPolicySpecRulesValidateForeachContext | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiCall': toJson_ClusterPolicySpecRulesValidateForeachContextApiCall(obj.apiCall),
    'configMap': toJson_ClusterPolicySpecRulesValidateForeachContextConfigMap(obj.configMap),
    'imageRegistry': toJson_ClusterPolicySpecRulesValidateForeachContextImageRegistry(obj.imageRegistry),
    'name': obj.name,
    'variable': toJson_ClusterPolicySpecRulesValidateForeachContextVariable(obj.variable),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Deny defines conditions used to pass or fail a validation rule.
 *
 * @schema ClusterPolicySpecRulesValidateForeachDeny
 */
export interface ClusterPolicySpecRulesValidateForeachDeny {
  /**
   * Multiple conditions can be declared under an `any` or `all` statement. A direct list of conditions (without `any` or `all` statements) is also supported for backwards compatibility but will be deprecated in the next major release. See: https://kyverno.io/docs/writing-policies/validate/#deny-rules
   *
   * @schema ClusterPolicySpecRulesValidateForeachDeny#conditions
   */
  readonly conditions?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachDeny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachDeny(obj: ClusterPolicySpecRulesValidateForeachDeny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions are used to determine if a policy rule should be applied by evaluating a set of conditions. The declaration can contain nested `any` or `all` statements. See: https://kyverno.io/docs/writing-policies/preconditions/
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditions
 */
export interface ClusterPolicySpecRulesValidateForeachPreconditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditions#all
   */
  readonly all?: ClusterPolicySpecRulesValidateForeachPreconditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditions#any
   */
  readonly any?: ClusterPolicySpecRulesValidateForeachPreconditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachPreconditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachPreconditions(obj: ClusterPolicySpecRulesValidateForeachPreconditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * AnyAllConditions consists of conditions wrapped denoting a logical criteria to be fulfilled. AnyConditions get fulfilled when at least one of its sub-conditions passes. AllConditions get fulfilled only when all of its sub-conditions pass.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditions
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsConditions {
  /**
   * AllConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, all of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditions#all
   */
  readonly all?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll[];

  /**
   * AnyConditions enable variable-based conditional rule execution. This is useful for finer control of when an rule is applied. A condition can reference object data using JMESPath notation. Here, at least one of the conditions need to pass
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditions#any
   */
  readonly any?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsConditions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditions(obj: ClusterPolicySpecRulesVerifyImagesAttestationsConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'all': obj.all?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll(y)),
    'any': obj.any?.map(y => toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntries {
  /**
   * Annotations are used for image verification. Every specified key-value pair must exist and match in the verified payload. The payload may contain other key-value pairs.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Attestor is a nested AttestorSet used to specify a more complex set of match authorities
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#attestor
   */
  readonly attestor?: any;

  /**
   * Certificates specifies one or more certificates
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#certificates
   */
  readonly certificates?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates;

  /**
   * Keyless is a set of attribute used to verify a Sigstore keyless attestor. See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#keyless
   */
  readonly keyless?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless;

  /**
   * Keys specifies one or more public keys
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#keys
   */
  readonly keys?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys;

  /**
   * Repository is an optional alternate OCI repository to use for signatures and attestations that match this rule. If specified Repository will override other OCI image repository locations for this Attestor.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntries#repository
   */
  readonly repository?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntries' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntries(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntries | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'attestor': obj.attestor,
    'certificates': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates(obj.certificates),
    'keyless': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless(obj.keyless),
    'keys': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys(obj.keys),
    'repository': obj.repository,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector(obj: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesSelector
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesSelector(obj: ClusterPolicySpecRulesExcludeAllResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector(obj: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelector
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelector(obj: ClusterPolicySpecRulesExcludeAnyResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector(obj: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesSelector
 */
export interface ClusterPolicySpecRulesMatchAllResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesSelector(obj: ClusterPolicySpecRulesMatchAllResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * NamespaceSelector is a label selector for the resource namespace. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character).Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector(obj: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Selector is a label selector. Label keys and values in `matchLabels` support the wildcard characters `*` (matches zero or many characters) and `?` (matches one character). Wildcards allows writing label selectors like ["storage.k8s.io/*": "*"]. Note that using ["*" : "*"] matches any key and value but does not match an empty label set.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesSelector
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesSelector' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesSelector(obj: ClusterPolicySpecRulesMatchAnyResourcesSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall defines an HTTP request to the Kubernetes API server. The JSON data retrieved is stored in the context.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextApiCall
 */
export interface ClusterPolicySpecRulesMutateForeachContextApiCall {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the API server. For example a JMESPath of "items | length(@)" applied to the API server response to the URLPath "/apis/apps/v1/deployments" will return the total count of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * URLPath is the URL path to be used in the HTTP GET request to the Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments"). The format required is the same format used by the `kubectl get --raw` command.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextApiCall#urlPath
   */
  readonly urlPath: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextApiCall(obj: ClusterPolicySpecRulesMutateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextConfigMap
 */
export interface ClusterPolicySpecRulesMutateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextConfigMap(obj: ClusterPolicySpecRulesMutateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistry
 */
export interface ClusterPolicySpecRulesMutateForeachContextImageRegistry {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextImageRegistry(obj: ClusterPolicySpecRulesMutateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesMutateForeachContextVariable
 */
export interface ClusterPolicySpecRulesMutateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
   * @schema ClusterPolicySpecRulesMutateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesMutateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachContextVariable(obj: ClusterPolicySpecRulesMutateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll
 */
export interface ClusterPolicySpecRulesMutateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicySpecRulesMutateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAll(obj: ClusterPolicySpecRulesMutateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny
 */
export interface ClusterPolicySpecRulesMutateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicySpecRulesMutateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMutateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMutateForeachPreconditionsAny(obj: ClusterPolicySpecRulesMutateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * APICall defines an HTTP request to the Kubernetes API server. The JSON data retrieved is stored in the context.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextApiCall
 */
export interface ClusterPolicySpecRulesValidateForeachContextApiCall {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to transform the JSON response returned from the API server. For example a JMESPath of "items | length(@)" applied to the API server response to the URLPath "/apis/apps/v1/deployments" will return the total count of deployments across all namespaces.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * URLPath is the URL path to be used in the HTTP GET request to the Kubernetes API server (e.g. "/api/v1/namespaces" or  "/apis/apps/v1/deployments"). The format required is the same format used by the `kubectl get --raw` command.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextApiCall#urlPath
   */
  readonly urlPath: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextApiCall' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextApiCall(obj: ClusterPolicySpecRulesValidateForeachContextApiCall | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'urlPath': obj.urlPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ConfigMap is the ConfigMap reference.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextConfigMap
 */
export interface ClusterPolicySpecRulesValidateForeachContextConfigMap {
  /**
   * Name is the ConfigMap name.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextConfigMap#name
   */
  readonly name: string;

  /**
   * Namespace is the ConfigMap namespace.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextConfigMap#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextConfigMap' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextConfigMap(obj: ClusterPolicySpecRulesValidateForeachContextConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * ImageRegistry defines requests to an OCI/Docker V2 registry to fetch image details.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistry
 */
export interface ClusterPolicySpecRulesValidateForeachContextImageRegistry {
  /**
   * JMESPath is an optional JSON Match Expression that can be used to transform the ImageData struct returned as a result of processing the image reference.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistry#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Reference is image reference to a container image in the registry. Example: ghcr.io/kyverno/kyverno:latest
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextImageRegistry#reference
   */
  readonly reference: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextImageRegistry' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextImageRegistry(obj: ClusterPolicySpecRulesValidateForeachContextImageRegistry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jmesPath': obj.jmesPath,
    'reference': obj.reference,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Variable defines an arbitrary JMESPath context variable that can be defined inline.
 *
 * @schema ClusterPolicySpecRulesValidateForeachContextVariable
 */
export interface ClusterPolicySpecRulesValidateForeachContextVariable {
  /**
   * Default is an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
   *
   * @default an optional arbitrary JSON object that the variable may take if the JMESPath expression evaluates to nil
   * @schema ClusterPolicySpecRulesValidateForeachContextVariable#default
   */
  readonly default?: any;

  /**
   * JMESPath is an optional JMESPath Expression that can be used to transform the variable.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextVariable#jmesPath
   */
  readonly jmesPath?: string;

  /**
   * Value is any arbitrary JSON object representable in YAML or JSON form.
   *
   * @schema ClusterPolicySpecRulesValidateForeachContextVariable#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachContextVariable' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachContextVariable(obj: ClusterPolicySpecRulesValidateForeachContextVariable | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'default': obj.default,
    'jmesPath': obj.jmesPath,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll
 */
export interface ClusterPolicySpecRulesValidateForeachPreconditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll#key
   */
  readonly key?: any;

  /**
   * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll#operator
   */
  readonly operator?: ClusterPolicySpecRulesValidateForeachPreconditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachPreconditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAll(obj: ClusterPolicySpecRulesValidateForeachPreconditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny
 */
export interface ClusterPolicySpecRulesValidateForeachPreconditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny#key
   */
  readonly key?: any;

  /**
   * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny#operator
   */
  readonly operator?: ClusterPolicySpecRulesValidateForeachPreconditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesValidateForeachPreconditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesValidateForeachPreconditionsAny(obj: ClusterPolicySpecRulesValidateForeachPreconditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll#key
   */
  readonly key?: any;

  /**
   * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll#operator
   */
  readonly operator?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAllOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll(obj: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAll | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Condition defines variable-based conditional criteria for rule execution.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny {
  /**
   * Key is the context entry (using JMESPath) for conditional rule evaluation.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny#key
   */
  readonly key?: any;

  /**
   * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny#operator
   */
  readonly operator?: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAnyOperator;

  /**
   * Value is the conditional value, or set of values. The values can be fixed set or can be variables declared using JMESPath.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny#value
   */
  readonly value?: any;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny(obj: ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAny | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Certificates specifies one or more certificates
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates {
  /**
   * Certificate is an optional PEM encoded public certificate.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates#cert
   */
  readonly cert?: string;

  /**
   * CertificateChain is an optional PEM encoded set of certificates used to verify
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates#certChain
   */
  readonly certChain?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If the value is nil, Rekor is not checked. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': obj.cert,
    'certChain': obj.certChain,
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keyless is a set of attribute used to verify a Sigstore keyless attestor. See https://github.com/sigstore/cosign/blob/main/KEYLESS.md.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless {
  /**
   * AdditionalExtensions are certificate-extensions used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#additionalExtensions
   */
  readonly additionalExtensions?: { [key: string]: string };

  /**
   * Issuer is the certificate issuer used for keyless signing.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#issuer
   */
  readonly issuer?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If the value is nil, Rekor is not checked and a root certificate chain is expected instead. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor;

  /**
   * Roots is an optional set of PEM encoded trusted root certificates. If not provided, the system roots are used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#roots
   */
  readonly roots?: string;

  /**
   * Subject is the verified identity used for keyless signing, for example the email address
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless#subject
   */
  readonly subject?: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalExtensions': ((obj.additionalExtensions) === undefined) ? undefined : (Object.entries(obj.additionalExtensions).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'issuer': obj.issuer,
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor(obj.rekor),
    'roots': obj.roots,
    'subject': obj.subject,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Keys specifies one or more public keys
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys {
  /**
   * Keys is a set of X.509 public keys used to verify image signatures. The keys can be directly specified or can be a variable reference to a key specified in a ConfigMap (see https://kyverno.io/docs/writing-policies/variables/). When multiple keys are specified each key is processed as a separate staticKey entry (.attestors[*].entries.keys) within the set of attestors and the count is applied across the keys.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#publicKeys
   */
  readonly publicKeys?: string;

  /**
   * Rekor provides configuration for the Rekor transparency log service. If the value is nil, Rekor is not checked. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
   *
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys#rekor
   */
  readonly rekor?: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeys | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'publicKeys': obj.publicKeys,
    'rekor': toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor(obj.rekor),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAllResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAllResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAnyResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesExcludeAnyResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAllResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAllResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAnyResourcesNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions
 */
export interface ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions(obj: ClusterPolicySpecRulesMatchAnyResourcesSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAllOperator
 */
export enum ClusterPolicySpecRulesMutateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = 'Equals',
  /** NotEquals */
  NOT_EQUALS = 'NotEquals',
  /** In */
  IN = 'In',
  /** AnyIn */
  ANY_IN = 'AnyIn',
  /** AllIn */
  ALL_IN = 'AllIn',
  /** NotIn */
  NOT_IN = 'NotIn',
  /** AnyNotIn */
  ANY_NOT_IN = 'AnyNotIn',
  /** AllNotIn */
  ALL_NOT_IN = 'AllNotIn',
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = 'GreaterThanOrEquals',
  /** GreaterThan */
  GREATER_THAN = 'GreaterThan',
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = 'LessThanOrEquals',
  /** LessThan */
  LESS_THAN = 'LessThan',
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = 'DurationGreaterThanOrEquals',
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = 'DurationGreaterThan',
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = 'DurationLessThanOrEquals',
  /** DurationLessThan */
  DURATION_LESS_THAN = 'DurationLessThan',
}

/**
 * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesMutateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicySpecRulesMutateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = 'Equals',
  /** NotEquals */
  NOT_EQUALS = 'NotEquals',
  /** In */
  IN = 'In',
  /** AnyIn */
  ANY_IN = 'AnyIn',
  /** AllIn */
  ALL_IN = 'AllIn',
  /** NotIn */
  NOT_IN = 'NotIn',
  /** AnyNotIn */
  ANY_NOT_IN = 'AnyNotIn',
  /** AllNotIn */
  ALL_NOT_IN = 'AllNotIn',
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = 'GreaterThanOrEquals',
  /** GreaterThan */
  GREATER_THAN = 'GreaterThan',
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = 'LessThanOrEquals',
  /** LessThan */
  LESS_THAN = 'LessThan',
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = 'DurationGreaterThanOrEquals',
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = 'DurationGreaterThan',
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = 'DurationLessThanOrEquals',
  /** DurationLessThan */
  DURATION_LESS_THAN = 'DurationLessThan',
}

/**
 * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAllOperator
 */
export enum ClusterPolicySpecRulesValidateForeachPreconditionsAllOperator {
  /** Equals */
  EQUALS = 'Equals',
  /** NotEquals */
  NOT_EQUALS = 'NotEquals',
  /** In */
  IN = 'In',
  /** AnyIn */
  ANY_IN = 'AnyIn',
  /** AllIn */
  ALL_IN = 'AllIn',
  /** NotIn */
  NOT_IN = 'NotIn',
  /** AnyNotIn */
  ANY_NOT_IN = 'AnyNotIn',
  /** AllNotIn */
  ALL_NOT_IN = 'AllNotIn',
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = 'GreaterThanOrEquals',
  /** GreaterThan */
  GREATER_THAN = 'GreaterThan',
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = 'LessThanOrEquals',
  /** LessThan */
  LESS_THAN = 'LessThan',
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = 'DurationGreaterThanOrEquals',
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = 'DurationGreaterThan',
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = 'DurationLessThanOrEquals',
  /** DurationLessThan */
  DURATION_LESS_THAN = 'DurationLessThan',
}

/**
 * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesValidateForeachPreconditionsAnyOperator
 */
export enum ClusterPolicySpecRulesValidateForeachPreconditionsAnyOperator {
  /** Equals */
  EQUALS = 'Equals',
  /** NotEquals */
  NOT_EQUALS = 'NotEquals',
  /** In */
  IN = 'In',
  /** AnyIn */
  ANY_IN = 'AnyIn',
  /** AllIn */
  ALL_IN = 'AllIn',
  /** NotIn */
  NOT_IN = 'NotIn',
  /** AnyNotIn */
  ANY_NOT_IN = 'AnyNotIn',
  /** AllNotIn */
  ALL_NOT_IN = 'AllNotIn',
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = 'GreaterThanOrEquals',
  /** GreaterThan */
  GREATER_THAN = 'GreaterThan',
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = 'LessThanOrEquals',
  /** LessThan */
  LESS_THAN = 'LessThan',
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = 'DurationGreaterThanOrEquals',
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = 'DurationGreaterThan',
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = 'DurationLessThanOrEquals',
  /** DurationLessThan */
  DURATION_LESS_THAN = 'DurationLessThan',
}

/**
 * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAllOperator
 */
export enum ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAllOperator {
  /** Equals */
  EQUALS = 'Equals',
  /** NotEquals */
  NOT_EQUALS = 'NotEquals',
  /** In */
  IN = 'In',
  /** AnyIn */
  ANY_IN = 'AnyIn',
  /** AllIn */
  ALL_IN = 'AllIn',
  /** NotIn */
  NOT_IN = 'NotIn',
  /** AnyNotIn */
  ANY_NOT_IN = 'AnyNotIn',
  /** AllNotIn */
  ALL_NOT_IN = 'AllNotIn',
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = 'GreaterThanOrEquals',
  /** GreaterThan */
  GREATER_THAN = 'GreaterThan',
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = 'LessThanOrEquals',
  /** LessThan */
  LESS_THAN = 'LessThan',
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = 'DurationGreaterThanOrEquals',
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = 'DurationGreaterThan',
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = 'DurationLessThanOrEquals',
  /** DurationLessThan */
  DURATION_LESS_THAN = 'DurationLessThan',
}

/**
 * Operator is the conditional operation to perform. Valid operators are: Equals, NotEquals, In, AnyIn, AllIn, NotIn, AnyNotIn, AllNotIn, GreaterThanOrEquals, GreaterThan, LessThanOrEquals, LessThan, DurationGreaterThanOrEquals, DurationGreaterThan, DurationLessThanOrEquals, DurationLessThan
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAnyOperator
 */
export enum ClusterPolicySpecRulesVerifyImagesAttestationsConditionsAnyOperator {
  /** Equals */
  EQUALS = 'Equals',
  /** NotEquals */
  NOT_EQUALS = 'NotEquals',
  /** In */
  IN = 'In',
  /** AnyIn */
  ANY_IN = 'AnyIn',
  /** AllIn */
  ALL_IN = 'AllIn',
  /** NotIn */
  NOT_IN = 'NotIn',
  /** AnyNotIn */
  ANY_NOT_IN = 'AnyNotIn',
  /** AllNotIn */
  ALL_NOT_IN = 'AllNotIn',
  /** GreaterThanOrEquals */
  GREATER_THAN_OR_EQUALS = 'GreaterThanOrEquals',
  /** GreaterThan */
  GREATER_THAN = 'GreaterThan',
  /** LessThanOrEquals */
  LESS_THAN_OR_EQUALS = 'LessThanOrEquals',
  /** LessThan */
  LESS_THAN = 'LessThan',
  /** DurationGreaterThanOrEquals */
  DURATION_GREATER_THAN_OR_EQUALS = 'DurationGreaterThanOrEquals',
  /** DurationGreaterThan */
  DURATION_GREATER_THAN = 'DurationGreaterThan',
  /** DurationLessThanOrEquals */
  DURATION_LESS_THAN_OR_EQUALS = 'DurationLessThanOrEquals',
  /** DurationLessThan */
  DURATION_LESS_THAN = 'DurationLessThan',
}

/**
 * Rekor provides configuration for the Rekor transparency log service. If the value is nil, Rekor is not checked. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor {
  /**
   * URL is the address of the transparency log. Defaults to the public log https://rekor.sigstore.dev.
   *
   * @default the public log https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesCertificatesRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If the value is nil, Rekor is not checked and a root certificate chain is expected instead. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor {
  /**
   * URL is the address of the transparency log. Defaults to the public log https://rekor.sigstore.dev.
   *
   * @default the public log https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeylessRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Rekor provides configuration for the Rekor transparency log service. If the value is nil, Rekor is not checked. If an empty object is provided the public instance of Rekor (https://rekor.sigstore.dev) is used.
 *
 * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor
 */
export interface ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor {
  /**
   * URL is the address of the transparency log. Defaults to the public log https://rekor.sigstore.dev.
   *
   * @default the public log https://rekor.sigstore.dev.
   * @schema ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor(obj: ClusterPolicySpecRulesVerifyImagesAttestorsEntriesKeysRekor | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

